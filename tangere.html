/* loads fixed and extented Polymer version -- always load Tangere.html instead of Polymer.html in all Tangere Apps */
<script>
  var useNativeCSSProperties = true;
  if (navigator.appVersion.indexOf('Edge') > -1) useNativeCSSProperties = false;
  Polymer = { lazyRegister: true, useNativeCSSProperties: useNativeCSSProperties };
</script> 
<link rel="import" href="../polymer/polymer.html">

<!-- include global utility libs -->
<script src="../moment/moment.js"></script>
<script src="cookies.js"></script>

<script>
  (function (scope) {

    // globals
    Tangere = window.Tangere || {};
    Tangere.behaviors = Tangere.behaviors || {};
    Tangere.config = Tangere.config || {};
    Tangere.session = Tangere.session || {};
    Tangere.session.temp = Tangere.session.temp || {};
    Tangere.session.user = Tangere.session.user || {};
    Tangere.session.location = window.location;

    // browser detection 
    Tangere.session.browser = Tangere.session.browser || _getBrowser();

    function _getBrowser() {
      var browser = {};
      var ua = navigator.userAgent;

      browser.android = !!ua.match(/Android/i);
      browser.ios = !!ua.match(/iPhone|iPod|iPad/i)
      browser.mobile = browser.android || browser.ios;
      browser.desktop = !browser.mobile;

      // running in an extension - currently only indirectly detectable      
      browser.extension = (window.location.pathname.indexOf("/Extension") == 0);

      return browser;
    }


    // disable async in chrome as a workaround for https://github.com/Polymer/polymer/issues/2522 
    var _importHref = scope.Base.importHref;
    scope.Base.importHref = function (u, s, e, a) {      
      if (scope.Settings.useNativeCustomElements) a = false;     
      return _importHref.call(this,u,s,e,a);
    }
  

    // fix template nesting bug by copying template node.content to dom node._content after import
    scope.Base.instanceTemplate = function (template) {
      var dom = document.importNode(template._content || template.content, true);
      fixImportedNodes(template._content || template.content, dom);
      return dom;
    }

    function fixImportedNodes(node, orig) {
      var a, i, il;

      switch (node.nodeType) {

      case document.ELEMENT_NODE:
        if (node.tagName == "TEMPLATE") {
          orig._content = node.content; // copying to ._content as updating .content fails in Safari
        }

        // handle childes recursively
        if (node.childNodes && node.childNodes.length > 0) {
          for (i = 0, il = node.childNodes.length; i < il; i++) {
            fixImportedNodes(node.childNodes[i], orig.childNodes[i]);
          }
        }

      case document.DOCUMENT_FRAGMENT_NODE:
        for (i = 0, il = node.childNodes.length; i < il; ++i) {
          fixImportedNodes(node.childNodes[i], orig.childNodes[i]);
        }
      }
    }

    Tangere.behavior = {};

    Tangere.behavior.handleLink = {

      ignoreEvent: function (e) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      },
      handleLink: function (e) {
        
        // allow childs to set a different target url, if not provided use default url
        var href = "", el;

        if (!href && e.url) {
          href = e.url;
          el = e
        };

        if (!href && e.currentTarget && e.currentTarget.href) {
          href = e.currentTarget.href;
          el = e.currentTarget
        };

        if (!href && e.currentTarget.attributes && e.currentTarget.attributes.url) {
          href = e.currentTarget.attributes.url.value;
          el = e.currentTarget
        };

        if (!href && e.detail && e.detail.sourceEvent && e.detail.sourceEvent.currentTarget && e.detail.sourceEvent.currentTarget.href) {
          href = e.detail.sourceEvent.currentTarget.href;
          el = e.detail.sourceEvent.currentTarget
        };

        if (!href) console.log("handLink Url missing");

        // highlight current element
        if (el) {
          Polymer.dom(el).classList.add("active");
          setTimeout(function () {
            Polymer.dom(el).classList.remove("active");
          }.bind(this), 300);
        }



        // when running in IFrame and we also have a direct link to the external url open it
        if (el && el.getAttribute("xref")) {

          // running in embeded mode
          if (window.parentIFrame != null) {
            href = el.getAttribute("xref");
            window.parentIFrame.sendMessage({
              cmd: "navigate-to",
              url: href
            });
            return;
          }

          // chrome extension -> open in new tab
          if (window.chrome && !!chrome.runtime.id) {
            href = el.getAttribute("xref");
            window.open(href, '_blank');
            return;
          }
        }


        // convert absolute link to app to relative
        if (href.indexOf(window.location.origin + window.location.pathname + "#") == 0) {
          href = href.substring(href.indexOf("#"));
        }

        if (href) {
          if (href.indexOf("#") == 0) {

            Polymer.signal("busy-start-async");
            Polymer.signal("navigate-to", href);

          } else {
            window.open(href, '_blank');
          }
        }
        e.preventDefault();
        e.stopPropagation();
        return false;
      },
    };


    // -- global repository for languages
    scope.atI18nLocales = Polymer.atI18nLocales || {

      add: function (localName, locale, translations) {
        this[localName] = this[localName] || {};
        this[localName][locale.toLowerCase()] = translations;
      }

    };

  })(Polymer);
</script>
