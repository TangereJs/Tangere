/* loads fixed and extented Polymer version -- always load Tangere.html instead of Polymer.html in all Tangere Apps */
<link rel="import" href="../polymer/polymer.html">

<script>
	(function (scope) {

		// globals
		Tangere = window.Tangere || {};
		Tangere.session = Tangere.session || {};
		Tangere.session.temp = Tangere.session.temp || {};
		

		// convert all css variables to const, so first assignment of CSS can't be changed
    /*
		Tangere.styleVars = {};
    Polymer.StyleProperties.collectProperties = function (rule, properties) {
			var info = rule.propertyInfo;
			if (info) {
				if (info.properties) {
					Polymer.Base.mixin(properties, info.properties);
					return true;
				}
			} else {
				var m, rx = this.rx.VAR_ASSIGN;
				var cssText = rule.parsedCssText;
				var any;
				while (m = rx.exec(cssText)) {
					// note: group 2 is var, 3 is mixin

					var vname = m[1];
					var vval = (m[2] || m[3]).trim();

					Tangere.styleVars[vname] = Tangere.styleVars[vname] || vval;
					properties[m[1]] = Tangere.styleVars[vname];

					any = true;
				}
				return any;
			}
		}
    */
    
		// fix template nesting bug by copying template node.content to dom node._content after import
		scope.Base.instanceTemplate = function (template) {
			var dom = document.importNode(template._content || template.content, true);
			fixImportedNodes(template._content || template.content, dom);
			return dom;
		}

		function fixImportedNodes(node, orig) {
			var a, i, il;

			switch (node.nodeType) {

			case document.ELEMENT_NODE:
				if (node.tagName == "TEMPLATE") {
					orig._content = node.content; // copying to ._content as updating .content fails in Safari
				}

				// handle childes recursively          
				if (node.childNodes && node.childNodes.length > 0) {
					for (i = 0, il = node.childNodes.length; i < il; i++) {
						fixImportedNodes(node.childNodes[i], orig.childNodes[i]);
					}
				}

			case document.DOCUMENT_FRAGMENT_NODE:
				for (i = 0, il = node.childNodes.length; i < il; ++i) {
					fixImportedNodes(node.childNodes[i], orig.childNodes[i]);
				}
			}
		}

		Tangere.behavior = {};

		Tangere.behavior.handleLink = {

		  ignoreEvent: function (e) {
		    e.preventDefault();
		    e.stopPropagation();
		    return false;
		  },
		  handleLink: function (e) {
		    // allow childs to set a different target url, if not provided use default url
		    var href = "", el;
		    if (!href && e.url) { href = e.url; el = e };
		    if (!href && e.currentTarget && e.currentTarget.href) { href =  e.currentTarget.href; el = e.currentTarget };
		    if (!href && e.currentTarget.attributes && e.currentTarget.attributes.url) { href = e.currentTarget.attributes.url.value; el = e.currentTarget };
		    if (!href && e.detail && e.detail.sourceEvent && e.detail.sourceEvent.currentTarget && e.detail.sourceEvent.currentTarget.href) { href = e.detail.sourceEvent.currentTarget.href; el = e.detail.sourceEvent.currentTarget };
		    if (!href) console.log("handLink Url missing");
		    
        // highlight current element
		    if (el) {
		      Polymer.dom(el).classList.add("active");
		      setTimeout(function () {
		        Polymer.dom(el).classList.remove("active");
		      }.bind(this), 300);
		    }
		    

		    // convert absolute link to app to relative
		    if (href.indexOf(window.location.origin + window.location.pathname + "#") == 0) {
		      href = href.substring(href.indexOf("#"));
		    }

		    if (href) {
		      if (href.indexOf("#") == 0) {
		       		        
		        Polymer.signal("busy-start-async");		        
            Polymer.signal("navigate-to", href);

		      } else {
		        window.open(href, '_blank');
		      }
		    }
		    e.preventDefault();
		    e.stopPropagation();
		    return false;
		  },
		};


	})(Polymer);
</script>
